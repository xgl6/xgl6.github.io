<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<title>
    性感六
</title>
<!--[if lt IE 9]><script src="//cdn.bootcss.com/html5shiv/r29/html5.js"></script><![endif]-->
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<meta name="author" content="性感六">
<meta name="description" content="每一行代码都是改变世界的力量">
<meta name="keywords" content="性感六">
<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
<link rel="stylesheet" href="https://xgl6.github.io/styles/main.css" />
<link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/css/style.min.css" />
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/script.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/icon.min.js"></script>
        
            <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/Card/prism.min.js"></script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/css/Card/prism.min.css" />
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css">
            <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js"></script>
            
                <!--点击特效-->
                <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/love.min.js"></script>
                
                        <!--CDN样式-->
                        <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/hit-kounter-lc-0.3.0.js"></script>
                        <script src="https://cdn1.lncld.net/static/js/av-min-1.5.0.js"></script>
                        
                            <script>
                                (function() {
                                    var bp = document.createElement('script');
                                    var curProtocol = window.location.protocol.split(':')[0];
                                    if (curProtocol === 'https') {
                                        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                                    } else {
                                        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                                    }
                                    var s = document.getElementsByTagName("script")[0];
                                    s.parentNode.insertBefore(bp, s);
                                })();
                            </script>
                            
</head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="https://xgl6.github.io">
                    性感六
                </a>
            </div>
            <div id="tp-weather-widget"></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">
                        首页
                    </a>
                    
                    <a class="menu-item" href="/posts">
                        文章
                    </a>
                    
                    <a class="menu-item" href="/archives">
                        归档
                    </a>
                    
                    <a class="menu-item" href="/tags">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/post/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
            <form id="gridea-search-form" data-update="1600304702364" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
            </form>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="https://xgl6.github.io">
                            性感六
                        </a>
                        <!--en-->
                        <a id="mobile-toggle-theme-en" class="a en">&nbsp;Dark</a>
                        <!--zh-->
                        <a id="mobile-toggle-theme-zh" class="a zh">&nbsp;&#x6697;&#x9ED1;</a>
                    </div>
                    <form id="gridea-search-form" data-update="1600304702364" action="/search/index.html">
                        <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
                    </form>
                    <!--en-->
                    <div class="menu-toggle" id="menu-toggle-en" onclick="mobileBtn()">&#9776; Menu</div>
                    <!--zh-->
                    <div class="menu-toggle" id="menu-toggle-zh" onclick="mobileBtn()">&#9776; &#x83DC;&#x5355;</div>

                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/">
                            首页
                        </a>
                        
                        <a class="menu-item" href="/posts">
                            文章
                        </a>
                        
                        <a class="menu-item" href="/archives">
                            归档
                        </a>
                        
                        <a class="menu-item" href="/tags">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/post/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementById("menu-toggle-en");
        var toggleMenu_zh = document.getElementById("menu-toggle-zh");

        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.display != "none") {
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        } else if (toggleMenu_zh.display != "none") {
            if (toggleMenu_zh.classList.contains("active")) {
                toggleMenu_zh.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu_zh.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }

    }
</script>



    <script>
        (function(a, h, g, f, e, d, c, b) {
            b = function() {
                d = h.createElement(g);
                c = h.getElementsByTagName(g)[0];
                d.src = e;
                d.charset = "utf-8";
                d.async = 1;
                c.parentNode.insertBefore(d, c)
            };
            a["SeniverseWeatherWidgetObject"] = f;
            a[f] || (a[f] = function() {
                (a[f].q = a[f].q || []).push(arguments)
            });
            a[f].l = +new Date();
            if (a.attachEvent) {
                a.attachEvent("onload", b)
            } else {
                a.addEventListener("load", b, false)
            }
        }(window, document, "script", "SeniverseWeatherWidget", "//cdn.sencdn.com/widget2/static/js/bundle.js?t=" + parseInt((new Date().getTime() / 100000000).toString(), 10)));
        window.SeniverseWeatherWidget('show', {
            flavor: "slim",
            location: "WWEFQFPJZ7T8",
            geolocation: true,
            language: "auto",
            unit: "c",
            theme: "auto",
            token: "61bcc333-3305-4728-9465-6785274bb0a3",
            hover: "enabled",
            container: "tp-weather-widget"
        })
    </script>
    
            <div class="main">
                <div class="container">
                    <article class="post-wrap">
                        <header class="post-header">
                            <h1 class="post-title">
                                Shiro安全框架
                            </h1>
                            
                                    <!--zh-->
                                    <div class="post-meta zh">
                                        &#x4F5C;&#x8005;:
                                        <a itemprop="author" rel="author" href="/">
                                            性感六
                                        </a>
                                        <span class="post-time">&#x65E5;&#x671F;: <a href="#">2020-09-12</a></span>
                                        <span class="post-readtime">&#x9605;&#x8BFB;&#x65F6;&#x95F4;:<a
                                    href="#">31.1
                                    &#x5206;&#x949F;</a></span>
                                        <span class="post-words">&#x5B57;&#x6570;:<a href="#">7549</a></span>
                                        
                                            <span class="post-category">&#x5206;&#x7C7B;:
                                
                                <a href="https://xgl6.github.io/tag/XXzPKxnX6/">java</a>
                                
                                <a href="https://xgl6.github.io/tag/yP-_JkI1T/">shiro</a>
                                
                            </span>
                                            
                                                阅读量:
                                                <span data-hk-page="current"> - </span>
                                                
                                    </div>
                                    
                        </header>
                        
                            <img class="post-feature-image" src="https://xgl6.github.io/post-images/shiro.jpg" alt="">
                          
                        <div class="post-content">
                            <h1 id="shiro安全框架">Shiro安全框架</h1>
<h2 id="0-前言">0. 前言</h2>
<figure data-type="image" tabindex="1"><img src="https://xgl6.github.io/post-images/shiro-an-quan-kuang-jia/yuanjiao.png" alt="yuanjiao" loading="lazy"></figure>
<h3 id="01-常见问题">0.1 常见问题</h3>
<ol>
<li>传统web项目如何进行请求的合法性验证,?</li>
<li>Token和Session相比真正的优势在哪里,?</li>
<li>使用Token的正确姿势是什么,?</li>
</ol>
<h3 id="02-具体业务场景">0.2 具体业务场景</h3>
<h4 id="021-传统web存在的问题">0.2.1 传统Web存在的问题</h4>
<ol>
<li>开发人员在编写代码过程中一点都没有做请求的校验,安全性为0</li>
<li>开发人员统一使用Session进行请求的判断,即在登录认证成功后,将用户信息存储在Session中,凡是涉及到校验权限的请求,在相关代码里,都要从当前Session中提取信息.</li>
</ol>
<p>服务端使用Session的弊端以及为何要使用token的文章 , <a href="https://blog.csdn.net/mydistance/article/details/84545768">请看这里</a></p>
<h4 id="022-简单总结">0.2.2 简单总结</h4>
<ol>
<li>
<p>首先Session如果存储在服务器内存中,如果Session过多，势必会影响服务器性能。</p>
</li>
<li>
<p>Session如果存储在服务器内存中，在大型分布式中(服务器很多台的情况下)很难做到多个服务器之间Session共享</p>
</li>
<li>
<p>Session和对应的SessionId可以存储在数据库中(不要被网上有些文章误导了，说什么只能存在内存中)，虽然绝大多数情况下是存储在内存中。客户端拿着SessionId去服务器内存或者数据库中查找对应的Session</p>
</li>
<li>
<p>token一般放在请求头中，在前后端分离的时代，服务器认证通过之后，会返回给客户端一个token</p>
</li>
<li>
<p>token和Session一样，都可以存储在数据库，都设置有过期时间</p>
</li>
<li>
<p>在移动端，token的应用价值更高，因为移动端不支持Cookie</p>
</li>
</ol>
<blockquote>
<p>服务器如何校验请求中的token是否为登录认证的时返回给客户端的token,?</p>
</blockquote>
<ol>
<li>
<p>将token值和创建时间和过期时间保存在数据库，每一次请求根据token去数据库里进行查询比对，来判断是否合法。但是这种方式和将Session存储在数据库里没啥区别啊，每次请求都要进行数据库的查询操作，当请求很多时，数据库压力也很大，同时还要定期删除过期的token</p>
</li>
<li>
<p>将token值和创建时间和过期时间保存redis中，这样可以保证请求多的时候，redis数据库可以很好的扛住压力，同时redis也提供了key的过期时间，解决了1中的两个问题，但是同样的解决方式也可以用在Session上啊，那为什么还要用你啊？(Session也不是没有分布式解决方案的，总不能为了用token而用toke吧，他的厉害之处在哪)</p>
</li>
<li>
<p>不存储token，无论在缓存中或者数据库中。toekn和session相比，最重要的优势应该在于减少服务器的压力，不论是内存压力还是数据库的压力。思路大致如下：用户登录认证通过之后----&gt;返回给客户端的token应该是加密了的token，这个加密算法是关键，大致思路是这样的：要将用户的部分信息和请求的URL，时间戳融合在一起，返回给客户端。下次客户端请求时，会根据URL，时间戳，和部分用户信息重新生成一个token，将这个token和客户端请求中带的token比较，如果相同则这次请求合法。这样token不用占用存储空间，而且加解密的过程要比数据库查询快得多。具体也可以参考 <a href="https://www.jianshu.com/p/f124eda56fe4">这篇文章</a></p>
</li>
</ol>
<h2 id="1-什么是shiro">1. 什么是Shiro</h2>
<h3 id="11-什么是shiro">1.1 什么是Shiro</h3>
<p>Apache Shiro是一个强大且易用的Java安全框架,执行<strong>身份验证、授权、密码和会话管理</strong>。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序.</p>
<p>Apache Shiro 的首要目标是易于使用和理解。安全有时候是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖复杂的地方，露出一个干净而直观的 API，来简化开发人员在使他们的应用程序安全上的努力。以下是你可以用 Apache Shiro 所做的事情：</p>
<ul>
<li>验证用户来核实他们的身份</li>
<li>对用户执行访问控制，如：
<ul>
<li>判断用户是否被分配了一个确定的安全角色</li>
<li>判断用户是否被允许做某事</li>
</ul>
</li>
<li>在任何环境下使用 Session API，即使没有 Web 或 EJB 容器。</li>
<li>在身份验证，访问控制期间或在会话的生命周期，对事件作出反应。</li>
<li>聚集一个或多个用户安全数据的数据源，并作为一个单一的复合用户“视图”。</li>
<li>启用单点登录（SSO）功能。</li>
<li>为没有关联到登录的用户启用&quot;Remember Me&quot;服务</li>
</ul>
<h3 id="12-与spring-security的对比">1.2 与Spring Security的对比</h3>
<p><strong>shiro :</strong></p>
<p>Shiro较之 Spring Security，Shiro在保持强大功能的同时，还在简单性和灵活性方面拥有巨大优势。</p>
<ol>
<li>易于理解的 Java Security API；</li>
<li>简单的身份认证（登录），支持多种数据源（LDAP，JDBC，Kerberos，ActiveDirectory 等）；</li>
<li>对角色的简单的签权（访问控制），支持细粒度的签权；</li>
<li>支持一级缓存，以提升应用程序的性能；</li>
<li>内置的基于 POJO 企业会话管理，适用于 Web 以及非 Web 的环境；</li>
<li>异构客户端会话访问；</li>
<li>非常简单的加密 API；</li>
<li>不跟任何的框架或者容器捆绑，可以独立运行</li>
</ol>
<p><strong>Spring Security：</strong></p>
<p>除了不能脱离Spring，shiro的功能它都有。而且Spring Security对Oauth、OpenID也有支持,Shiro则需要自己手动实现。Spring Security的权限细粒度更高。</p>
<p><a href="https://baike.baidu.com/item/%E9%87%8D%E9%87%8F%E7%BA%A7%E6%A1%86%E6%9E%B6/1666355?fr=aladdin">点我了解</a></p>
<h3 id="13-shiro的功能模块">1.3 Shiro的功能模块</h3>
<p>Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。Shiro可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。这不就是我们想要的嘛，而且Shiro的API也是非常简单；其基本功能点如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191110103857623.png" alt="image-20191110103857623" loading="lazy"></figure>
<ul>
<li>
<p>Authentication：身份认证/登录，验证用户是不是拥有相应的身份。</p>
</li>
<li>
<p>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情。</p>
</li>
<li>
<p>Session Management：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的。</p>
</li>
<li>
<p>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储。</p>
</li>
<li>
<p>Web Support：Shiro 的 web 支持的 API 能够轻松地帮助保护 Web 应用程序。</p>
</li>
<li>
<p>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率。</p>
</li>
<li>
<p>Concurrency：Apache Shiro 利用它的并发特性来支持多线程应用程序。</p>
</li>
<li>
<p>Testing：测试支持的存在来帮助你编写单元测试和集成测试，并确保你的能够如预期的一样安全。</p>
</li>
<li>
<p>&quot;Run As&quot;：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。</p>
</li>
<li>
<p>&quot;Remember Me&quot;：记住我。</p>
</li>
</ul>
<h2 id="2-shiro的内部结构">2. Shiro的内部结构</h2>
<figure data-type="image" tabindex="3"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191110104045148.png" alt="image-20191110104045148" loading="lazy"></figure>
<p><strong>Subject</strong>：主体，可以看到主体可以是任何可以与应用交互的“用户”；</p>
<p><strong>SecurityManager</strong>：相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。</p>
<p><strong>Authenticator</strong>：认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</p>
<p><strong>Authrizer</strong>：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</p>
<p><strong>Realm</strong>：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；</p>
<p><strong>SessionManager</strong>：如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所以，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；</p>
<p><strong>SessionDAO</strong>：DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；</p>
<p><strong>CacheManager</strong>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p>
<p><strong>Cryptography</strong>：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。</p>
<h2 id="3-应用程序使用shiro">3. 应用程序使用Shiro</h2>
<figure data-type="image" tabindex="4"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191110104431288.png" alt="image-20191110104431288" loading="lazy"></figure>
<p>也就是说对于我们而言，最简单的一个Shiro应用：</p>
<ol>
<li>应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；</li>
<li>我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</li>
</ol>
<p><strong>从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。</strong></p>
<h2 id="4-shiro的入门">4. Shiro的入门</h2>
<h3 id="41-搭建基于ini的运行环境">4.1 搭建基于ini的运行环境</h3>
<ul>
<li>创建工程导入shiro坐标</li>
</ul>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-logging&lt;/groupId&gt;
            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;version&gt;1.1.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="42-用户认证">4.2 用户认证</h3>
<p>认证：身份认证/登录，验证用户是不是拥有相应的身份。基于shiro的认证，是通过subject的login方法完成用户认证工作的</p>
<ol>
<li>在resource目录下创建shiro的ini配置文件构造模拟数据（shiro-auth.ini）</li>
</ol>
<pre><code class="language-ini">[users]
#模拟从数据库查询的用户
#数据格式  用户名=密码
lxy=123456789
xgl=987654321
</code></pre>
<ol start="2">
<li>测试用户认证</li>
</ol>
<pre><code class="language-java">@Test
  public void testLogin() throws Exception{
    //1.加载ini配置文件创建SecurityManager
    Factory&lt;SecurityManager&gt; factory = new
IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);
    //2.获取securityManager
    SecurityManager securityManager = factory.getInstance();
    //3.将securityManager绑定到当前运行环境
    SecurityUtils.setSecurityManager(securityManager);
    //4.创建主体(此时的主体还为经过认证)
    Subject subject = SecurityUtils.getSubject();
    /**
    * 模拟登录，和传统等不同的是需要使用主体进行登录
    */
    //5.构造主体登录的凭证（即用户名/密码）
    //第一个参数：登录用户名，第二个参数：登录密码
    UsernamePasswordToken upToken = new UsernamePasswordToken(&quot;lxy&quot;,&quot;123456789&quot;);
    //6.主体登录
    subject.login(upToken);
    //7.验证是否登录成功
    System.out.println(&quot;用户登录成功=&quot;+subject.isAuthenticated());
    //8.登录成功获取数据
    //getPrincipal 获取登录成功的安全数据
    System.out.println(subject.getPrincipal());
 }
</code></pre>
<h3 id="43-用户授权">4.3 用户授权</h3>
<p>授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限</p>
<ol>
<li>在resource目录下创建shiro的ini配置文件构造模拟数据（shiro-prem.ini）</li>
</ol>
<pre><code class="language-ini">[users]
#模拟从数据库查询的用户
#数据格式  用户名=密码,角色1,角色2..
lxy=123456789,role1,role2
xgl=987654321,role2
[roles]
#模拟从数据库查询的角色和权限列表
#数据格式  角色名=权限1，权限2
role1=user:save,user:update
role2=user:update,user:delete
role3=user:find
</code></pre>
<ol start="2">
<li>完成用户授权</li>
</ol>
<pre><code class="language-java">package cn.xgl6.shiro;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.junit.Test;
public class ShiroTest1 {
  @Test
  public void testLogin() throws Exception{
    //1.加载ini配置文件创建SecurityManager
    Factory&lt;SecurityManager&gt; factory = new
IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);
    //2.获取securityManager
    SecurityManager securityManager = factory.getInstance();
    //3.将securityManager绑定到当前运行环境
    SecurityUtils.setSecurityManager(securityManager);
    //4.创建主体(此时的主体还为经过认证)
    Subject subject = SecurityUtils.getSubject();
    /**
    * 模拟登录，和传统等不同的是需要使用主体进行登录
    */
    //5.构造主体登录的凭证（即用户名/密码）
    //第一个参数：登录用户名，第二个参数：登录密码
    UsernamePasswordToken upToken = new UsernamePasswordToken(&quot;xgl&quot;,&quot;987654321&quot;);
    //6.主体登录
    subject.login(upToken);
    //7.用户认证成功之后才可以完成授权工作
    boolean hasPerm = subject.isPermitted(&quot;user:save&quot;);
    System.out.println(&quot;用户是否具有save权限=&quot;+hasPerm);
    }
}
</code></pre>
<h3 id="44-自定义realm">4.4 自定义Realm</h3>
<p>Realm域：Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源</p>
<ol>
<li>自定义Realm</li>
</ol>
<pre><code class="language-java">package cn.xgl6.shiro;
import org.apache.shiro.authc.*;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import java.util.ArrayList;
import java.util.List;
/**
* 自定义realm，需要继承AuthorizingRealm父类
*   重写父类中的两个方法
*     doGetAuthorizationInfo   ：授权
*     doGetAuthenticationInfo   ：认证
*/
public class PermissionRealm extends AuthorizingRealm {
  @Override
  public void setName(String name) {
    super.setName(&quot;permissionRealm&quot;);
 }
  /**
  * 授权：授权的主要目的就是查询数据库获取用户的所有角色和权限信息
  */
  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection
principalCollection) {
    // 1.从principals获取已认证用户的信息
    String username = (String) principalCollection.getPrimaryPrincipal();
    /**
    * 正式系统：应该从数据库中根据用户名或者id查询
    *     这里为了方便演示，手动构造
    */
    // 2.模拟从数据库中查询的用户所有权限
    List&lt;String&gt; permissions = new ArrayList&lt;String&gt;();
    permissions.add(&quot;user:save&quot;);// 用户的创建
    permissions.add(&quot;user:update&quot;);// 商品添加权限
    // 3.模拟从数据库中查询的用户所有角色
    List&lt;String&gt; roles = new ArrayList&lt;String&gt;();
    roles.add(&quot;role1&quot;);
    roles.add(&quot;role2&quot;);
    // 4.构造权限数据
    SimpleAuthorizationInfo simpleAuthorizationInfo = new
SimpleAuthorizationInfo();
    // 5.将查询的权限数据保存到simpleAuthorizationInfo
    simpleAuthorizationInfo.addStringPermissions(permissions);
    // 6.将查询的角色数据保存到simpleAuthorizationInfo
    simpleAuthorizationInfo.addRoles(roles);
    return simpleAuthorizationInfo;
 }
  /**
  * 认证：认证的主要目的，比较用户输入的用户名密码是否和数据库中的一致
  */
  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken
authenticationToken) throws AuthenticationException {
    //1.获取登录的upToken
    UsernamePasswordToken upToken = (UsernamePasswordToken)authenticationToken;
    //2.获取输入的用户名密码
    String username = upToken.getUsername();
    String password = new String(upToken.getPassword());
    /**
    * 3.验证用户名密码是否正确
    * 正式系统：应该从数据库中查询用户并比较密码是否一致
    *     为了测试，只要输入的密码为123456则登录成功
    */
    if(!password.equals(&quot;123456&quot;)) {
      throw  new RuntimeException(&quot;用户名或密码错误&quot;);//抛出异常表示认证失败
   }else{
      SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username,
password,
          this.getName());
      return info;
   }
 }
}
</code></pre>
<ol start="2">
<li>配置shiro的ini配置文件（shiro-realm.ini）</li>
</ol>
<pre><code class="language-ini">[main]
#声明realm
permRealm=cn.xgl6.shiro.PermissionRealm
#注册realm到securityManager中
securityManager.realms=$permRealm
</code></pre>
<ol start="3">
<li>验证</li>
</ol>
<pre><code class="language-java">package cn.xgl6.shiro;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.junit.Before;
import org.junit.Test;
public class ShiroTest2 {
  private SecurityManager securityManager;
  @Before
  public void init() throws Exception{
    //1.加载ini配置文件创建SecurityManager
    Factory&lt;SecurityManager&gt; factory = new
IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;);
    //2.获取securityManager
    SecurityManager securityManager = factory.getInstance();
    //13.将securityManager绑定到当前运行环境
    SecurityUtils.setSecurityManager(securityManager);
 }
  @Test
  public void testLogin() throws Exception{
    //1.创建主体(此时的主体还为经过认证)
    Subject subject = SecurityUtils.getSubject();
    //2.构造主体登录的凭证（即用户名/密码）
    UsernamePasswordToken upToken = new UsernamePasswordToken(&quot;lisi&quot;,&quot;123456&quot;);
    //3.主体登录
    subject.login(upToken);
    //登录成功验证是否具有role1角色
    //System.out.println(&quot;当前用户具有role1=&quot;+subject.hasRole(&quot;role3&quot;));
    //登录成功验证是否具有某些权限
    System.out.println(&quot;当前用户具有user:save权限=&quot;+subject.isPermitted(&quot;user:save&quot;));
 }
}
</code></pre>
<h3 id="45-认证与授权的执行流程分析">4.5 认证与授权的执行流程分析</h3>
<p><strong>( 1 ) 认证流程</strong></p>
<figure data-type="image" tabindex="5"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191110105748436.png" alt="image-20191110105748436" loading="lazy"></figure>
<ol>
<li>首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；</li>
<li>SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证；</li>
<li>Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现；</li>
<li>Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认<br>
ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；</li>
<li>Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</li>
</ol>
<p><strong>( 2 ) 授权流程</strong></p>
<figure data-type="image" tabindex="6"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191110105912998.png" alt="image-20191110105912998" loading="lazy"></figure>
<ol>
<li>首先调用Subject.isPermitted/hasRole接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer；</li>
<li>Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例；</li>
<li>在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限；</li>
<li>Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给<br>
ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted/hasRole会返回true，否则返回false表示授权失败。</li>
</ol>
<h2 id="5-shiro的高级应用">5. Shiro的高级应用</h2>
<h3 id="51-shiro在spring-boot工程中的应用">5.1 Shiro在Spring Boot工程中的应用</h3>
<p>在之前的讲解中只是单独的使用shiro，方便大伙对shiro有一个直观且清晰的认知，我们今天就来看一下shiro在SpringBoot工程中如何使用以及其他特性</p>
<h4 id="511-案例说明">5.1.1 案例说明</h4>
<p>使用springBoot构建应用程序，整合shiro框架完成用户认证与授权。</p>
<p><a href="https://baike.baidu.com/item/%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/8795406?fr=aladdin&amp;fromtitle=RBAC&amp;fromid=1328788">RBAC模型</a></p>
<h5 id="5111-数据库表">5.1.1.1 数据库表</h5>
<figure data-type="image" tabindex="7"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191112203026161.png" alt="image-20191112203026161" loading="lazy"></figure>
<h5 id="5112-基本项目结构">5.1.1.2 基本项目结构</h5>
<p><a href="file://E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cshiro-g.7z">点我打开</a></p>
<h4 id="512-整合shiro">5.1.2 整合Shiro</h4>
<h5 id="5121-spring和shiro的整合依赖">5.1.2.1 Spring和Shiro的整合依赖</h5>
<pre><code class="language-xml">&lt;!--shiro和spring整合--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
	&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
	&lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--shiro核心包--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
	&lt;artifactId&gt;shiro-core&lt;/artifactId&gt;
	&lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--shiro与redis整合--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.crazycake&lt;/groupId&gt;
	&lt;artifactId&gt;shiro-redis&lt;/artifactId&gt;
	&lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="5122-修改登录方法">5.1.2.2 修改登录方法</h5>
<p>认证：身份认证/登录，验证用户是不是拥有相应的身份。基于shiro的认证，shiro需要采集到用户登录数据使用subject的login方法进入realm完成认证工作。</p>
<pre><code class="language-java">/**
     * 传统登录
     *      前端发送登录请求 =&gt; 接口部分获取用户名密码 =&gt; 程序员在接口手动控制
     * shiro登录
     *      前端发送登录请求 =&gt; 接口获取用户名密码 =&gt; 通过subject.login() =&gt; realm域认证方法
     * @param userName
     * @param pwd
     * @return
     */
    @RequestMapping(value = &quot;/login&quot;)
    public String login(String userName, String pwd){
        try {
            /**
             * 密码加密
             *      shiro提供的md5加密
             *      Md5Hash
             *          参数一:加密的内容
             *          参数二:盐(加密的混淆字符串),一般是用户名
             *          参数三:加密次数
             */
            pwd = new Md5Hash(pwd,userName,3).toString();
            //1.构造登录令牌
            UsernamePasswordToken token = new UsernamePasswordToken(userName,pwd);
            //2.获取subject
            Subject subject = SecurityUtils.getSubject();
            //3.调用subject进行登录
            subject.login(token);
            return &quot;登录成功&quot;;
        }catch (Exception e){
            return &quot;用户名或密码错误&quot;;
        }

    }
</code></pre>
<h5 id="5123-自定义realm">5.1.2.3 自定义Realm</h5>
<pre><code class="language-java">package cn.xgl6.realm;

import cn.xgl6.pojo.Permission;
import cn.xgl6.pojo.Role;
import cn.xgl6.pojo.User;
import cn.xgl6.service.UserService;
import org.apache.shiro.authc.*;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.HashSet;
import java.util.Set;

/**
 * @author xgl
 * @create 2019-11-12 18:49
 */
public class UserRealm extends AuthorizingRealm {
    @Autowired
    private UserService userService;
    @Override
    public void setName(String name){

        super.setName(&quot;UserRealm&quot;);
    }

    /**
     * 授权
     *      判断用户是否具有相应的权限
     *      先认证,---安全数据
     *      再授权 -- 根据安全数据获取用户是否具有相应权限
     * @param principalCollection
     * @return
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        //1.获取已认证的用户数据
        User user = (User) principalCollection.getPrimaryPrincipal();
        //2.根据用户数据获取用户权限信息(所有角色,所有权限)
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        Set&lt;String&gt; roles = new HashSet&lt;&gt;();
        Set&lt;String&gt; perms = new HashSet&lt;&gt;();
        for (Role role : user.getRoles()) {
            roles.add(role.getName());
            for (Permission perm : role.getPermissions()) {
                perms.add(perm.getCode());
            }
        }
        info.setStringPermissions(perms);
        info.setRoles(roles);
        return info;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        //1.获取登录的用户名和密码
        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;
        String userName = token.getUsername();
        System.out.println(&quot;realm中的用户名&quot; + userName);

        String pwd = String.valueOf(token.getPassword());
        System.out.println(&quot;realm中的密码&quot; + pwd);
        //2.根据用户名查询数据库
        User user = userService.findByName(userName);
        //3.判断是否一致
        if (user != null &amp;&amp; user.getPassword().equals(pwd)){
            //4.如果一致,返回安全数据
            return new SimpleAuthenticationInfo(user, pwd, getName());
        }else {
            //5.返回null或者抛出异常
            return null;
        }

    }
}

</code></pre>
<h4 id="513-shiro的配置">5.1.3 Shiro的配置</h4>
<p>SecurityManager 是 Shiro 架构的心脏，用于协调内部的多个组件完成全部认证授权的过程。例如通过调用realm完成认证与登录。使用基于springboot的配置方式完成SecurityManager，Realm的装配</p>
<pre><code class="language-java">package cn.xgl6;

import cn.xgl6.realm.UserRealm;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @author xgl
 * @create 2019-11-12 19:50
 */
@Configuration
public class ShiroConfiguration {
    //1.创建realm
    @Bean
    public UserRealm getRealm(){
        return new UserRealm();
    }
    //2.创建安全管理器
    @Bean
    public SecurityManager getSecurityManager(UserRealm realm){
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(realm);
        return securityManager;
    }
    //3.配置shiro过滤器工厂

    /**
     * 在web程序中,shiro进行权限控制全都是通过一组过滤器集合进行控制的
     *
     *
     * @param securityManager
     * @return
     */
    @Bean
    public ShiroFilterFactoryBean getShiroFilter(SecurityManager securityManager){
        //1.创建过滤器工厂
        ShiroFilterFactoryBean filterFactory = new ShiroFilterFactoryBean();
        //2.设置安全管理器
        filterFactory.setSecurityManager(securityManager);
        //3.通用配置(跳转的登录页面,未授权跳转的页面)
        //3.1 指定登录页面
        filterFactory.setLoginUrl(&quot;/autherror?code=1&quot;);
        //3.2指定未授权页面
        filterFactory.setUnauthorizedUrl(&quot;/autherror?code=2&quot;);
        //4.设置过滤器集合
        /**
         * 通过有顺序的 map 集合进行控制
         *      key = 拦截的URL地址
         *      value = 过滤器类型
         */
        Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;();
        //匿名访问
        //filterMap.put(&quot;/user/home&quot;,&quot;anon&quot;);
        filterMap.put(&quot;/user/home&quot;,&quot;perms[user-home]&quot;);
        //必须认证后才能访问
        filterMap.put(&quot;/user/**&quot;,&quot;authc&quot;);
        filterFactory.setFilterChainDefinitionMap(filterMap);
        //5.返回过滤器工厂
        return filterFactory;
    }
    //4.开启对shiro注解的支持
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
    }
    /**
     * Shiro生命周期处理器
     */
    @Bean(name = &quot;lifecycleBeanPostProcessor&quot;)
    public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() {
        return new LifecycleBeanPostProcessor();
    }

    /**
     * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证
     */
    @Bean
    @DependsOn(&quot;lifecycleBeanPostProcessor&quot;)
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator();
        creator.setProxyTargetClass(true);
        return creator;
    }
}

</code></pre>
<h4 id="514-shiro中的过滤器">5.1.4 Shiro中的过滤器</h4>
<table>
<thead>
<tr>
<th></th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>anon</strong></td>
<td>无参,开放权限,可以理解为匿名用户或游客</td>
</tr>
<tr>
<td><strong>authc</strong></td>
<td>无参,需要认证</td>
</tr>
<tr>
<td>logout</td>
<td>无参,注销,执行后会跳转到<code>shiroFilterFactoryBean.setLoginUrl();</code> 设置的url</td>
</tr>
<tr>
<td>authcBasic</td>
<td>无参，表示 httpBasic 认证</td>
</tr>
<tr>
<td>user</td>
<td>无参，表示必须存在用户，当登入操作时不做检查</td>
</tr>
<tr>
<td>ssl</td>
<td>无参，表示安全的URL请求，协议为 https</td>
</tr>
<tr>
<td><strong>perms[user]</strong></td>
<td>参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user,admin”]，当有多个参数时必须每个参数都通过才算通过</td>
</tr>
<tr>
<td><strong>roles[admin]</strong></td>
<td>参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”],当有多个参数时必须每个参数都通过才算通过</td>
</tr>
<tr>
<td>rest[user]</td>
<td>根据请求的方法，相当于 perms[user:method]，其中 method 为 post，get，delete 等</td>
</tr>
<tr>
<td>port[8081]</td>
<td>当请求的URL端口不是8081时，跳转到当前访问主机HOST的8081端口</td>
</tr>
</tbody>
</table>
<h4 id="515-授权">5.1.5 授权</h4>
<p>授权：即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情<br>
shiro支持基于过滤器的授权方式也支持注解的授权方式</p>
<h5 id="5151-基于配置的授权">5.1.5.1 基于配置的授权</h5>
<p>在shiro中可以使用过滤器的方式配置目标地址的请求权限</p>
<pre><code class="language-java">//配置请求连接过滤器配置
    //匿名访问（所有人员可以使用）
    filterMap.put(&quot;/user/home&quot;, &quot;anon&quot;);
    //具有指定权限访问
    filterMap.put(&quot;/user/find&quot;, &quot;perms[user-find]&quot;);
    //认证之后访问（登录之后可以访问）
    filterMap.put(&quot;/user/**&quot;, &quot;authc&quot;);
    //具有指定角色可以访问
    filterMap.put(&quot;/user/**&quot;, &quot;roles[系统管理员]&quot;);
</code></pre>
<blockquote>
<p>基于配置的方式进行授权，一旦操作用户不具备操作权限，目标地址不会被执行。会跳转到指定的url连接地址。</p>
</blockquote>
<h5 id="5152-基于注解的授权">5.1.5.2 基于注解的授权</h5>
<p>( 1 ) <strong>RequiresPermissions</strong></p>
<blockquote>
<p>配置到方法上,表示执行此方法必须具有指定的权限</p>
</blockquote>
<pre><code class="language-java">//查询
  @RequiresPermissions(value = &quot;user-find&quot;)
  public String find() {
    return &quot;查询用户成功&quot;;
 }
</code></pre>
<p>( 2 ) <strong>RequiresRoles</strong></p>
<blockquote>
<p>配置到方法上，表明执行此方法必须具有指定的角色</p>
</blockquote>
<pre><code class="language-java">//查询
  @RequiresRoles(value = &quot;系统管理员&quot;)
  public String find() {
    return &quot;查询用户成功&quot;;
 }
</code></pre>
<blockquote>
<p>基于注解的配置方式进行授权，一旦操作用户不具备操作权限，目标方法不会被执行，而且会抛出AuthorizationException 异常。所以需要做好统一异常处理完成未授权处理</p>
</blockquote>
<h3 id="52-shiro中的会话管理">5.2 Shiro中的会话管理</h3>
<figure data-type="image" tabindex="8"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191118210634860.png" alt="image-20191118210634860" loading="lazy"></figure>
<p>在Shiro里所有用户的会话信息都会由Shiro来进行控制,Shiro提供的会话可以用于JavaSE/JavaEE环境,不依赖任何底层容器,可以独立使用,是完整的会话模块.</p>
<p>通过Shiro的会话管理器,(SecurityManager) 进行统一的会话管理</p>
<h4 id="521-什么是shiro的会话管理">5.2.1 什么是Shiro的会话管理</h4>
<p><strong>SessionManager</strong>(会话管理器) : 管理所有的Subject的session包括创建,维护,删除,失效,验证等工作.</p>
<p>SessionManager是顶层组件,由SecurityManager管理.</p>
<p>Shiro提供了三个默认实现 :</p>
<ol>
<li>DefaultSessionManager : 用于JavaSE环境</li>
<li>ServletContainerSessionManager : 用于Web环境,直接使用Servlet容器的会话.</li>
<li>DefaultWebSessionManager : 用于Web环境,自己维护会话,(自己维护着会话,直接废弃了Servlet容器的会话管理).</li>
</ol>
<p>在web程序中,通过Shiro的Subject.login()方法登录成功以后,用户的认证信息实际上是保存在HttpSession中的.</p>
<p>通过如下代码验证 :</p>
<pre><code class="language-java">//登录成功后，打印所有session内容
@RequestMapping(value=&quot;/show&quot;)
public String show(HttpSession session) {
    // 获取session中所有的键值
    Enumeration&lt;?&gt; enumeration = session.getAttributeNames();
    // 遍历enumeration中的
    while (enumeration.hasMoreElements()) {
      // 获取session键值
      String name = enumeration.nextElement().toString();
      // 根据键值取session中的值
      Object value = session.getAttribute(name);
      // 打印结果
      System.out.println(&quot;&lt;B&gt;&quot; + name + &quot;&lt;/B&gt;=&quot; + value + &quot;&lt;br&gt;/n&quot;);
   }
    return &quot;查看session成功&quot;;
 }
</code></pre>
<h4 id="522-应用场景分析">5.2.2 应用场景分析</h4>
<p>在分布式系统或者微服务架构下，都是通过统一的认证中心进行用户认证。如果使用默认会话管理，用户信息只会保存到一台服务器上。那么其他服务就需要进行会话的同步。</p>
<figure data-type="image" tabindex="9"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191113201459275.png" alt="image-20191113201459275" loading="lazy"></figure>
<p>会话管理器可以指定sessionId的生成以及获取方式。</p>
<p>通过sessionDao完成模拟session存入，取出等操作</p>
<h4 id="523-shiro结合redis的统一会话管理">5.2.3 Shiro结合Redis的统一会话管理</h4>
<h5 id="5231-步骤分析">5.2.3.1 步骤分析</h5>
<figure data-type="image" tabindex="10"><img src="E:%5C6%5CMD%5CShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.assets%5Cimage-20191113203927613.png" alt="image-20191113203927613" loading="lazy"></figure>
<h5 id="5232-构建环境">5.2.3.2 构建环境</h5>
<p>( 1 ) 使用开源组件Shiro-Redis可以方便的构建Shiro与Redis的整合工程</p>
<pre><code class="language-xml">&lt;dependency&gt;
&lt;groupId&gt;org.crazycake&lt;/groupId&gt;
&lt;artifactId&gt;shiro-redis&lt;/artifactId&gt;
&lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>( 2 ) 在Spring Boot配置文件中添加Redis的配置</p>
<pre><code class="language-yml">redis:
 	host: 127.0.0.1
 	port: 6379
</code></pre>
<h5 id="5233-自定义shiro会话管理器">5.2.3.3 自定义Shiro会话管理器</h5>
<pre><code class="language-java">/**
* 自定义的sessionManager
*/
public class CustomSessionManager extends DefaultWebSessionManager {
  /**
  * 头信息中具有sessionid
  *   请求头：Authorization： sessionid
  *
  * 指定sessionId的获取方式
  */
    protected Serializable getSessionId(ServletRequest request, ServletResponse
response) {
    //获取请求头Authorization中的数据
    String id = WebUtils.toHttp(request).getHeader(&quot;Authorization&quot;);
    if(StringUtils.isEmpty(id)) {
      //如果没有携带，生成新的sessionId
      return super.getSessionId(request,response);
   }else{
      //返回sessionId；
      request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,
&quot;header&quot;);
      request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);
    
 request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID,
Boolean.TRUE);
      return id;
   }
 }
}
</code></pre>
<h5 id="5234-配置shiro基于redis的会话管理">5.2.3.4 配置Shiro基于Redis的会话管理</h5>
<p>在Shiro配置类 <code>cn.xgl6.ShiroConfiguration</code> 配置</p>
<ol>
<li>
<p>配置Shiro的RedisManager , 通过shiro-redis包提供的RedisManager统一对Redis操作</p>
<pre><code class="language-java">@Value(&quot;${spring.redis.host}&quot;)
private String host;
@Value(&quot;${spring.redis.port}&quot;)
private int port;
//配置shiro redisManager
public RedisManager redisManager() {
  RedisManager redisManager = new RedisManager();
  redisManager.setHost(host);
  redisManager.setPort(port);
  return redisManager;
}
</code></pre>
</li>
<li>
<p>Shiro内部有自己的本地缓存机制,为了更加统一方便管理,全部替换成Redis实现</p>
<pre><code class="language-java">//配置Shiro的缓存管理器
//使用redis实现
public RedisCacheManager cacheManager() {
	RedisCacheManager redisCacheManager = new RedisCacheManager();
	redisCacheManager.setRedisManager(redisManager());
	return redisCacheManager;
}
</code></pre>
</li>
<li>
<p>配置SessionDao,使用shiro-redis包提供的SessionDao</p>
<pre><code class="language-java">/**
* RedisSessionDAO shiro sessionDao层的实现 通过redis
* 使用的是shiro-redis开源插件
*/
public RedisSessionDAO redisSessionDAO() {
  	RedisSessionDAO redisSessionDAO = new RedisSessionDAO();
  	redisSessionDAO.setRedisManager(redisManager());
  	return redisSessionDAO;
}
</code></pre>
</li>
<li>
<p>配置会话管理器,指定SessionDao的依赖关系</p>
<pre><code class="language-java">/**
  * 3.会话管理器
  */
  public DefaultWebSessionManager sessionManager() {
    CustomSessionManager sessionManager = new CustomSessionManager();
    sessionManager.setSessionDAO(redisSessionDAO());
    return sessionManager;
 }
</code></pre>
</li>
<li>
<p>统一交给SecurityManager管理</p>
<pre><code class="language-java">//配置安全管理器
  @Bean
  public SecurityManager securityManager(CustomRealm realm) {
    //使用默认的安全管理器
    DefaultWebSecurityManager securityManager = new
DefaultWebSecurityManager(realm);
    // 自定义session管理 使用redis
    securityManager.setSessionManager(sessionManager());
    // 自定义缓存实现 使用redis
    securityManager.setCacheManager(cacheManager());
    //将自定义的realm交给安全管理器统一调度管理
    securityManager.setRealm(realm);
    return securityManager;
 }
</code></pre>
</li>
</ol>

                        </div>
                        
                            <div class="post-toc">
                                <ul class="markdownIt-TOC">
<li><a href="#shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6">Shiro安全框架</a>
<ul>
<li><a href="#0-%E5%89%8D%E8%A8%80">0. 前言</a>
<ul>
<li><a href="#01-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">0.1 常见问题</a></li>
<li><a href="#02-%E5%85%B7%E4%BD%93%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF">0.2 具体业务场景</a>
<ul>
<li><a href="#021-%E4%BC%A0%E7%BB%9Fweb%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">0.2.1 传统Web存在的问题</a></li>
<li><a href="#022-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93">0.2.2 简单总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AFshiro">1. 什么是Shiro</a>
<ul>
<li><a href="#11-%E4%BB%80%E4%B9%88%E6%98%AFshiro">1.1 什么是Shiro</a></li>
<li><a href="#12-%E4%B8%8Espring-security%E7%9A%84%E5%AF%B9%E6%AF%94">1.2 与Spring Security的对比</a></li>
<li><a href="#13-shiro%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97">1.3 Shiro的功能模块</a></li>
</ul>
</li>
<li><a href="#2-shiro%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84">2. Shiro的内部结构</a></li>
<li><a href="#3-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8shiro">3. 应用程序使用Shiro</a></li>
<li><a href="#4-shiro%E7%9A%84%E5%85%A5%E9%97%A8">4. Shiro的入门</a>
<ul>
<li><a href="#41-%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Eini%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">4.1 搭建基于ini的运行环境</a></li>
<li><a href="#42-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81">4.2 用户认证</a></li>
<li><a href="#43-%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83">4.3 用户授权</a></li>
<li><a href="#44-%E8%87%AA%E5%AE%9A%E4%B9%89realm">4.4 自定义Realm</a></li>
<li><a href="#45-%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">4.5 认证与授权的执行流程分析</a></li>
</ul>
</li>
<li><a href="#5-shiro%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8">5. Shiro的高级应用</a>
<ul>
<li><a href="#51-shiro%E5%9C%A8spring-boot%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">5.1 Shiro在Spring Boot工程中的应用</a>
<ul>
<li><a href="#511-%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E">5.1.1 案例说明</a>
<ul>
<li><a href="#5111-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8">5.1.1.1 数据库表</a></li>
<li><a href="#5112-%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">5.1.1.2 基本项目结构</a></li>
</ul>
</li>
<li><a href="#512-%E6%95%B4%E5%90%88shiro">5.1.2 整合Shiro</a>
<ul>
<li><a href="#5121-spring%E5%92%8Cshiro%E7%9A%84%E6%95%B4%E5%90%88%E4%BE%9D%E8%B5%96">5.1.2.1 Spring和Shiro的整合依赖</a></li>
<li><a href="#5122-%E4%BF%AE%E6%94%B9%E7%99%BB%E5%BD%95%E6%96%B9%E6%B3%95">5.1.2.2 修改登录方法</a></li>
<li><a href="#5123-%E8%87%AA%E5%AE%9A%E4%B9%89realm">5.1.2.3 自定义Realm</a></li>
</ul>
</li>
<li><a href="#513-shiro%E7%9A%84%E9%85%8D%E7%BD%AE">5.1.3 Shiro的配置</a></li>
<li><a href="#514-shiro%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8">5.1.4 Shiro中的过滤器</a></li>
<li><a href="#515-%E6%8E%88%E6%9D%83">5.1.5 授权</a>
<ul>
<li><a href="#5151-%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E6%8E%88%E6%9D%83">5.1.5.1 基于配置的授权</a></li>
<li><a href="#5152-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8E%88%E6%9D%83">5.1.5.2 基于注解的授权</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#52-shiro%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86">5.2 Shiro中的会话管理</a>
<ul>
<li><a href="#521-%E4%BB%80%E4%B9%88%E6%98%AFshiro%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86">5.2.1 什么是Shiro的会话管理</a></li>
<li><a href="#522-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90">5.2.2 应用场景分析</a></li>
<li><a href="#523-shiro%E7%BB%93%E5%90%88redis%E7%9A%84%E7%BB%9F%E4%B8%80%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86">5.2.3 Shiro结合Redis的统一会话管理</a>
<ul>
<li><a href="#5231-%E6%AD%A5%E9%AA%A4%E5%88%86%E6%9E%90">5.2.3.1 步骤分析</a></li>
<li><a href="#5232-%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83">5.2.3.2 构建环境</a></li>
<li><a href="#5233-%E8%87%AA%E5%AE%9A%E4%B9%89shiro%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E5%99%A8">5.2.3.3 自定义Shiro会话管理器</a></li>
<li><a href="#5234-%E9%85%8D%E7%BD%AEshiro%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86">5.2.3.4 配置Shiro基于Redis的会话管理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                            </div>
                            
                                
                                                    
                                                                    <!--Share-->
                                                                    <span style="margin-right:15px">
                        <i class="post-share"></i>
                        <span>&#x5206;&#x4EAB;:</span>
                                                                    <a title="QR 码" target="_blank" href="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://xgl6.github.io/post/shiro/"><i class="fa fa-qrcode"></i></a>
                                                                    <a title="QQ" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://xgl6.github.io/post/shiro/&sharesource=qzone&title=Shiro安全框架&pics=https://xgl6.github.io/images/avatar.png?v=1600304702364&summary="><i class="fa fa-qq"></i></a>
                                                                    <a title="新浪微博" target="_blank" href="https://service.weibo.com/share/share.php?url=https://xgl6.github.io/post/shiro/&sharesource=weibo&title=Shiro安全框架 + " - " + &pic="https://xgl6.github.io/images/avatar.png?v=1600304702364 "><i class="fa fa-weibo "></i></a>

                                                                    </span>
                                                                    
                                                                            <!--zh-->
                                                                            <section class="post-tags zh ">
                                                                                <div>
                                                                                    <span>&#x6807;&#x7B7E;:</span>
                                                                                    <span class="tag ">
                        
                        
                        <a href="https://xgl6.github.io/tag/XXzPKxnX6/">#
                    java
                        </a>
                        
                        <a href="https://xgl6.github.io/tag/yP-_JkI1T/">#
                    shiro
                        </a>
                        
                            
                                </span>
                                                                                </div>
                                                                                <div>
                                                                                    <a href="javascript:window.history.back();">
                        &#x8FD4;&#x56DE;</a>
                                                                                    <span>&dot;</span>
                                                                                    <a href="#">&#x4E3B;&#x9875;</a>
                                                                                </div>
                                                                            </section>

                                                                            
                                                                                <!---->
                                                                                <section class="post-nav">
                                                                                    
                                                                                            
                                                                                                <a class="next" rel="next" href="https://xgl6.github.io/post/hello-gridea/">
                                                                                                    Hello Gridea
                                                                                                </a>
                                                                                                
                                                                                </section>
                    </article>
                </div>
                
                                            
            </div>
    </div>
    </div>
    </div>
    
        <footer id="footer" class="footer">
            <div class="copyright">
                
                        
                            
                                <!--<b id="hitokoto"></b><br>-->
                                <br>
                                
                                        <svg viewBox="0 0 1024 1024" style="margin-left: 5px;margin-right: 5px;" version="1.0" width="8" height="8" class="my-face">
            <path
                d="M863.597631 513.574282l-271.33965-140.213484L729.783667 81.926656c3.583731-7.87141 7.167462-15.742819 7.167462-25.214109C736.887134 25.226908 708.345275 0.012799 672.635953 0.012799a63.611229 63.611229 0 0 0-39.293053 12.607055c-1.791866 1.59988-3.519736 3.19976-5.311602 3.19976L147.87531 418.925381a55.547834 55.547834 0 0 0-19.646527 47.356448c1.791866 17.278704 14.27093 33.021523 32.125591 42.492813l271.33965 141.749369L292.504463 945.221908c-12.479064 25.214109-1.791866 53.563983 23.166262 69.306802 10.751194 6.335525 23.230258 9.47129 35.709322 9.47129 16.062795 0 32.125591-4.735645 44.604655-15.742819l480.091993-403.297753a55.547834 55.547834 0 0 0 19.646526-47.228458 61.243407 61.243407 0 0 0-32.12559-44.156688z"
                fill="#93b5cf"></path>
        </svg>
                                        性感六 &copy;Copyright
                                            <script>
                                                var date = new Date();
                                                document.write("" + date.getFullYear());
                                            </script>
                                            <!--| Powered by-->
                                            <a href="" target="_blank">
                                                
                                            </a>
            </div>
            <div id="update" style="display:none;">
                on
            </div>
            
                <div id="version" style="display:none;">
                    1.7.6
                </div>
                
                    <script>
                        var port = '';
                        
                        document.write('<div id="home_path" style="display:none;">' + document.location.protocol + '//' + window.document.location.hostname + port + '</div>')
                    </script>
        </footer>
        
                <script>
                    
                    
                    
                    hitokoto();
                    
                    getStar();
                    hljs.initHighlighting();
                    console.clear();
                    
                    CheckVersion();
                    
                    var newDate = new Date();
                    newDate.setTime(1600304702364);
                    console.log(" Blog Update Time: " + newDate.toLocaleDateString());
                    console.log("\n %c \u26a1Theme:Chic Author's Blog:https://blog.itjoker.cn  Write By ITJoker  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;");
                </script>
        </div>
</body>
<script>
    scroll();
</script>

</html>
{"posts":[{"title":"Shiro安全框架","content":"Shiro安全框架 0. 前言 0.1 常见问题 传统web项目如何进行请求的合法性验证,? Token和Session相比真正的优势在哪里,? 使用Token的正确姿势是什么,? 0.2 具体业务场景 0.2.1 传统Web存在的问题 开发人员在编写代码过程中一点都没有做请求的校验,安全性为0 开发人员统一使用Session进行请求的判断,即在登录认证成功后,将用户信息存储在Session中,凡是涉及到校验权限的请求,在相关代码里,都要从当前Session中提取信息. 服务端使用Session的弊端以及为何要使用token的文章 , 请看这里 0.2.2 简单总结 首先Session如果存储在服务器内存中,如果Session过多，势必会影响服务器性能。 Session如果存储在服务器内存中，在大型分布式中(服务器很多台的情况下)很难做到多个服务器之间Session共享 Session和对应的SessionId可以存储在数据库中(不要被网上有些文章误导了，说什么只能存在内存中)，虽然绝大多数情况下是存储在内存中。客户端拿着SessionId去服务器内存或者数据库中查找对应的Session token一般放在请求头中，在前后端分离的时代，服务器认证通过之后，会返回给客户端一个token token和Session一样，都可以存储在数据库，都设置有过期时间 在移动端，token的应用价值更高，因为移动端不支持Cookie 服务器如何校验请求中的token是否为登录认证的时返回给客户端的token,? 将token值和创建时间和过期时间保存在数据库，每一次请求根据token去数据库里进行查询比对，来判断是否合法。但是这种方式和将Session存储在数据库里没啥区别啊，每次请求都要进行数据库的查询操作，当请求很多时，数据库压力也很大，同时还要定期删除过期的token 将token值和创建时间和过期时间保存redis中，这样可以保证请求多的时候，redis数据库可以很好的扛住压力，同时redis也提供了key的过期时间，解决了1中的两个问题，但是同样的解决方式也可以用在Session上啊，那为什么还要用你啊？(Session也不是没有分布式解决方案的，总不能为了用token而用toke吧，他的厉害之处在哪) 不存储token，无论在缓存中或者数据库中。toekn和session相比，最重要的优势应该在于减少服务器的压力，不论是内存压力还是数据库的压力。思路大致如下：用户登录认证通过之后----&gt;返回给客户端的token应该是加密了的token，这个加密算法是关键，大致思路是这样的：要将用户的部分信息和请求的URL，时间戳融合在一起，返回给客户端。下次客户端请求时，会根据URL，时间戳，和部分用户信息重新生成一个token，将这个token和客户端请求中带的token比较，如果相同则这次请求合法。这样token不用占用存储空间，而且加解密的过程要比数据库查询快得多。具体也可以参考 这篇文章 1. 什么是Shiro 1.1 什么是Shiro Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序. Apache Shiro 的首要目标是易于使用和理解。安全有时候是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖复杂的地方，露出一个干净而直观的 API，来简化开发人员在使他们的应用程序安全上的努力。以下是你可以用 Apache Shiro 所做的事情： 验证用户来核实他们的身份 对用户执行访问控制，如： 判断用户是否被分配了一个确定的安全角色 判断用户是否被允许做某事 在任何环境下使用 Session API，即使没有 Web 或 EJB 容器。 在身份验证，访问控制期间或在会话的生命周期，对事件作出反应。 聚集一个或多个用户安全数据的数据源，并作为一个单一的复合用户“视图”。 启用单点登录（SSO）功能。 为没有关联到登录的用户启用&quot;Remember Me&quot;服务 1.2 与Spring Security的对比 shiro : Shiro较之 Spring Security，Shiro在保持强大功能的同时，还在简单性和灵活性方面拥有巨大优势。 易于理解的 Java Security API； 简单的身份认证（登录），支持多种数据源（LDAP，JDBC，Kerberos，ActiveDirectory 等）； 对角色的简单的签权（访问控制），支持细粒度的签权； 支持一级缓存，以提升应用程序的性能； 内置的基于 POJO 企业会话管理，适用于 Web 以及非 Web 的环境； 异构客户端会话访问； 非常简单的加密 API； 不跟任何的框架或者容器捆绑，可以独立运行 Spring Security： 除了不能脱离Spring，shiro的功能它都有。而且Spring Security对Oauth、OpenID也有支持,Shiro则需要自己手动实现。Spring Security的权限细粒度更高。 点我了解 1.3 Shiro的功能模块 Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。Shiro可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。这不就是我们想要的嘛，而且Shiro的API也是非常简单；其基本功能点如下图所示： Authentication：身份认证/登录，验证用户是不是拥有相应的身份。 Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情。 Session Management：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的。 Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储。 Web Support：Shiro 的 web 支持的 API 能够轻松地帮助保护 Web 应用程序。 Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率。 Concurrency：Apache Shiro 利用它的并发特性来支持多线程应用程序。 Testing：测试支持的存在来帮助你编写单元测试和集成测试，并确保你的能够如预期的一样安全。 &quot;Run As&quot;：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。 &quot;Remember Me&quot;：记住我。 2. Shiro的内部结构 Subject：主体，可以看到主体可以是任何可以与应用交互的“用户”； SecurityManager：相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。 Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了； Authrizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能； Realm：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm； SessionManager：如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所以，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据； SessionDAO：DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能； CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能 Cryptography：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。 3. 应用程序使用Shiro 也就是说对于我们而言，最简单的一个Shiro应用： 应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager； 我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。 从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。 4. Shiro的入门 4.1 搭建基于ini的运行环境 创建工程导入shiro坐标 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4.2 用户认证 认证：身份认证/登录，验证用户是不是拥有相应的身份。基于shiro的认证，是通过subject的login方法完成用户认证工作的 在resource目录下创建shiro的ini配置文件构造模拟数据（shiro-auth.ini） [users] #模拟从数据库查询的用户 #数据格式 用户名=密码 lxy=123456789 xgl=987654321 测试用户认证 @Test public void testLogin() throws Exception{ //1.加载ini配置文件创建SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); //2.获取securityManager SecurityManager securityManager = factory.getInstance(); //3.将securityManager绑定到当前运行环境 SecurityUtils.setSecurityManager(securityManager); //4.创建主体(此时的主体还为经过认证) Subject subject = SecurityUtils.getSubject(); /** * 模拟登录，和传统等不同的是需要使用主体进行登录 */ //5.构造主体登录的凭证（即用户名/密码） //第一个参数：登录用户名，第二个参数：登录密码 UsernamePasswordToken upToken = new UsernamePasswordToken(&quot;lxy&quot;,&quot;123456789&quot;); //6.主体登录 subject.login(upToken); //7.验证是否登录成功 System.out.println(&quot;用户登录成功=&quot;+subject.isAuthenticated()); //8.登录成功获取数据 //getPrincipal 获取登录成功的安全数据 System.out.println(subject.getPrincipal()); } 4.3 用户授权 授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限 在resource目录下创建shiro的ini配置文件构造模拟数据（shiro-prem.ini） [users] #模拟从数据库查询的用户 #数据格式 用户名=密码,角色1,角色2.. lxy=123456789,role1,role2 xgl=987654321,role2 [roles] #模拟从数据库查询的角色和权限列表 #数据格式 角色名=权限1，权限2 role1=user:save,user:update role2=user:update,user:delete role3=user:find 完成用户授权 package cn.xgl6.shiro; import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.UsernamePasswordToken; import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; import org.junit.Test; public class ShiroTest1 { @Test public void testLogin() throws Exception{ //1.加载ini配置文件创建SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); //2.获取securityManager SecurityManager securityManager = factory.getInstance(); //3.将securityManager绑定到当前运行环境 SecurityUtils.setSecurityManager(securityManager); //4.创建主体(此时的主体还为经过认证) Subject subject = SecurityUtils.getSubject(); /** * 模拟登录，和传统等不同的是需要使用主体进行登录 */ //5.构造主体登录的凭证（即用户名/密码） //第一个参数：登录用户名，第二个参数：登录密码 UsernamePasswordToken upToken = new UsernamePasswordToken(&quot;xgl&quot;,&quot;987654321&quot;); //6.主体登录 subject.login(upToken); //7.用户认证成功之后才可以完成授权工作 boolean hasPerm = subject.isPermitted(&quot;user:save&quot;); System.out.println(&quot;用户是否具有save权限=&quot;+hasPerm); } } 4.4 自定义Realm Realm域：Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源 自定义Realm package cn.xgl6.shiro; import org.apache.shiro.authc.*; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import java.util.ArrayList; import java.util.List; /** * 自定义realm，需要继承AuthorizingRealm父类 * 重写父类中的两个方法 * doGetAuthorizationInfo ：授权 * doGetAuthenticationInfo ：认证 */ public class PermissionRealm extends AuthorizingRealm { @Override public void setName(String name) { super.setName(&quot;permissionRealm&quot;); } /** * 授权：授权的主要目的就是查询数据库获取用户的所有角色和权限信息 */ protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { // 1.从principals获取已认证用户的信息 String username = (String) principalCollection.getPrimaryPrincipal(); /** * 正式系统：应该从数据库中根据用户名或者id查询 * 这里为了方便演示，手动构造 */ // 2.模拟从数据库中查询的用户所有权限 List&lt;String&gt; permissions = new ArrayList&lt;String&gt;(); permissions.add(&quot;user:save&quot;);// 用户的创建 permissions.add(&quot;user:update&quot;);// 商品添加权限 // 3.模拟从数据库中查询的用户所有角色 List&lt;String&gt; roles = new ArrayList&lt;String&gt;(); roles.add(&quot;role1&quot;); roles.add(&quot;role2&quot;); // 4.构造权限数据 SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); // 5.将查询的权限数据保存到simpleAuthorizationInfo simpleAuthorizationInfo.addStringPermissions(permissions); // 6.将查询的角色数据保存到simpleAuthorizationInfo simpleAuthorizationInfo.addRoles(roles); return simpleAuthorizationInfo; } /** * 认证：认证的主要目的，比较用户输入的用户名密码是否和数据库中的一致 */ protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { //1.获取登录的upToken UsernamePasswordToken upToken = (UsernamePasswordToken)authenticationToken; //2.获取输入的用户名密码 String username = upToken.getUsername(); String password = new String(upToken.getPassword()); /** * 3.验证用户名密码是否正确 * 正式系统：应该从数据库中查询用户并比较密码是否一致 * 为了测试，只要输入的密码为123456则登录成功 */ if(!password.equals(&quot;123456&quot;)) { throw new RuntimeException(&quot;用户名或密码错误&quot;);//抛出异常表示认证失败 }else{ SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, password, this.getName()); return info; } } } 配置shiro的ini配置文件（shiro-realm.ini） [main] #声明realm permRealm=cn.xgl6.shiro.PermissionRealm #注册realm到securityManager中 securityManager.realms=$permRealm 验证 package cn.xgl6.shiro; import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.UsernamePasswordToken; import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; import org.junit.Before; import org.junit.Test; public class ShiroTest2 { private SecurityManager securityManager; @Before public void init() throws Exception{ //1.加载ini配置文件创建SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;); //2.获取securityManager SecurityManager securityManager = factory.getInstance(); //13.将securityManager绑定到当前运行环境 SecurityUtils.setSecurityManager(securityManager); } @Test public void testLogin() throws Exception{ //1.创建主体(此时的主体还为经过认证) Subject subject = SecurityUtils.getSubject(); //2.构造主体登录的凭证（即用户名/密码） UsernamePasswordToken upToken = new UsernamePasswordToken(&quot;lisi&quot;,&quot;123456&quot;); //3.主体登录 subject.login(upToken); //登录成功验证是否具有role1角色 //System.out.println(&quot;当前用户具有role1=&quot;+subject.hasRole(&quot;role3&quot;)); //登录成功验证是否具有某些权限 System.out.println(&quot;当前用户具有user:save权限=&quot;+subject.isPermitted(&quot;user:save&quot;)); } } 4.5 认证与授权的执行流程分析 ( 1 ) 认证流程 首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置； SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证； Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现； Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认 ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证； Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。 ( 2 ) 授权流程 首先调用Subject.isPermitted/hasRole接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer； Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例； 在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限； Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给 ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted/hasRole会返回true，否则返回false表示授权失败。 5. Shiro的高级应用 5.1 Shiro在Spring Boot工程中的应用 在之前的讲解中只是单独的使用shiro，方便大伙对shiro有一个直观且清晰的认知，我们今天就来看一下shiro在SpringBoot工程中如何使用以及其他特性 5.1.1 案例说明 使用springBoot构建应用程序，整合shiro框架完成用户认证与授权。 RBAC模型 5.1.1.1 数据库表 5.1.1.2 基本项目结构 点我打开 5.1.2 整合Shiro 5.1.2.1 Spring和Shiro的整合依赖 &lt;!--shiro和spring整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--shiro核心包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--shiro与redis整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; 5.1.2.2 修改登录方法 认证：身份认证/登录，验证用户是不是拥有相应的身份。基于shiro的认证，shiro需要采集到用户登录数据使用subject的login方法进入realm完成认证工作。 /** * 传统登录 * 前端发送登录请求 =&gt; 接口部分获取用户名密码 =&gt; 程序员在接口手动控制 * shiro登录 * 前端发送登录请求 =&gt; 接口获取用户名密码 =&gt; 通过subject.login() =&gt; realm域认证方法 * @param userName * @param pwd * @return */ @RequestMapping(value = &quot;/login&quot;) public String login(String userName, String pwd){ try { /** * 密码加密 * shiro提供的md5加密 * Md5Hash * 参数一:加密的内容 * 参数二:盐(加密的混淆字符串),一般是用户名 * 参数三:加密次数 */ pwd = new Md5Hash(pwd,userName,3).toString(); //1.构造登录令牌 UsernamePasswordToken token = new UsernamePasswordToken(userName,pwd); //2.获取subject Subject subject = SecurityUtils.getSubject(); //3.调用subject进行登录 subject.login(token); return &quot;登录成功&quot;; }catch (Exception e){ return &quot;用户名或密码错误&quot;; } } 5.1.2.3 自定义Realm package cn.xgl6.realm; import cn.xgl6.pojo.Permission; import cn.xgl6.pojo.Role; import cn.xgl6.pojo.User; import cn.xgl6.service.UserService; import org.apache.shiro.authc.*; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.springframework.beans.factory.annotation.Autowired; import java.util.HashSet; import java.util.Set; /** * @author xgl * @create 2019-11-12 18:49 */ public class UserRealm extends AuthorizingRealm { @Autowired private UserService userService; @Override public void setName(String name){ super.setName(&quot;UserRealm&quot;); } /** * 授权 * 判断用户是否具有相应的权限 * 先认证,---安全数据 * 再授权 -- 根据安全数据获取用户是否具有相应权限 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { //1.获取已认证的用户数据 User user = (User) principalCollection.getPrimaryPrincipal(); //2.根据用户数据获取用户权限信息(所有角色,所有权限) SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); Set&lt;String&gt; roles = new HashSet&lt;&gt;(); Set&lt;String&gt; perms = new HashSet&lt;&gt;(); for (Role role : user.getRoles()) { roles.add(role.getName()); for (Permission perm : role.getPermissions()) { perms.add(perm.getCode()); } } info.setStringPermissions(perms); info.setRoles(roles); return info; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { //1.获取登录的用户名和密码 UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; String userName = token.getUsername(); System.out.println(&quot;realm中的用户名&quot; + userName); String pwd = String.valueOf(token.getPassword()); System.out.println(&quot;realm中的密码&quot; + pwd); //2.根据用户名查询数据库 User user = userService.findByName(userName); //3.判断是否一致 if (user != null &amp;&amp; user.getPassword().equals(pwd)){ //4.如果一致,返回安全数据 return new SimpleAuthenticationInfo(user, pwd, getName()); }else { //5.返回null或者抛出异常 return null; } } } 5.1.3 Shiro的配置 SecurityManager 是 Shiro 架构的心脏，用于协调内部的多个组件完成全部认证授权的过程。例如通过调用realm完成认证与登录。使用基于springboot的配置方式完成SecurityManager，Realm的装配 package cn.xgl6; import cn.xgl6.realm.UserRealm; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor; import org.apache.shiro.spring.web.ShiroFilterFactoryBean; import org.apache.shiro.web.mgt.DefaultWebSecurityManager; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.LinkedHashMap; import java.util.Map; /** * @author xgl * @create 2019-11-12 19:50 */ @Configuration public class ShiroConfiguration { //1.创建realm @Bean public UserRealm getRealm(){ return new UserRealm(); } //2.创建安全管理器 @Bean public SecurityManager getSecurityManager(UserRealm realm){ DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(realm); return securityManager; } //3.配置shiro过滤器工厂 /** * 在web程序中,shiro进行权限控制全都是通过一组过滤器集合进行控制的 * * * @param securityManager * @return */ @Bean public ShiroFilterFactoryBean getShiroFilter(SecurityManager securityManager){ //1.创建过滤器工厂 ShiroFilterFactoryBean filterFactory = new ShiroFilterFactoryBean(); //2.设置安全管理器 filterFactory.setSecurityManager(securityManager); //3.通用配置(跳转的登录页面,未授权跳转的页面) //3.1 指定登录页面 filterFactory.setLoginUrl(&quot;/autherror?code=1&quot;); //3.2指定未授权页面 filterFactory.setUnauthorizedUrl(&quot;/autherror?code=2&quot;); //4.设置过滤器集合 /** * 通过有顺序的 map 集合进行控制 * key = 拦截的URL地址 * value = 过滤器类型 */ Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;(); //匿名访问 //filterMap.put(&quot;/user/home&quot;,&quot;anon&quot;); filterMap.put(&quot;/user/home&quot;,&quot;perms[user-home]&quot;); //必须认证后才能访问 filterMap.put(&quot;/user/**&quot;,&quot;authc&quot;); filterFactory.setFilterChainDefinitionMap(filterMap); //5.返回过滤器工厂 return filterFactory; } //4.开启对shiro注解的支持 @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor(); advisor.setSecurityManager(securityManager); return advisor; } /** * Shiro生命周期处理器 */ @Bean(name = &quot;lifecycleBeanPostProcessor&quot;) public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() { return new LifecycleBeanPostProcessor(); } /** * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 */ @Bean @DependsOn(&quot;lifecycleBeanPostProcessor&quot;) public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator(); creator.setProxyTargetClass(true); return creator; } } 5.1.4 Shiro中的过滤器 解释 anon 无参,开放权限,可以理解为匿名用户或游客 authc 无参,需要认证 logout 无参,注销,执行后会跳转到shiroFilterFactoryBean.setLoginUrl(); 设置的url authcBasic 无参，表示 httpBasic 认证 user 无参，表示必须存在用户，当登入操作时不做检查 ssl 无参，表示安全的URL请求，协议为 https perms[user] 参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user,admin”]，当有多个参数时必须每个参数都通过才算通过 roles[admin] 参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”],当有多个参数时必须每个参数都通过才算通过 rest[user] 根据请求的方法，相当于 perms[user:method]，其中 method 为 post，get，delete 等 port[8081] 当请求的URL端口不是8081时，跳转到当前访问主机HOST的8081端口 5.1.5 授权 授权：即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情 shiro支持基于过滤器的授权方式也支持注解的授权方式 5.1.5.1 基于配置的授权 在shiro中可以使用过滤器的方式配置目标地址的请求权限 //配置请求连接过滤器配置 //匿名访问（所有人员可以使用） filterMap.put(&quot;/user/home&quot;, &quot;anon&quot;); //具有指定权限访问 filterMap.put(&quot;/user/find&quot;, &quot;perms[user-find]&quot;); //认证之后访问（登录之后可以访问） filterMap.put(&quot;/user/**&quot;, &quot;authc&quot;); //具有指定角色可以访问 filterMap.put(&quot;/user/**&quot;, &quot;roles[系统管理员]&quot;); 基于配置的方式进行授权，一旦操作用户不具备操作权限，目标地址不会被执行。会跳转到指定的url连接地址。 5.1.5.2 基于注解的授权 ( 1 ) RequiresPermissions 配置到方法上,表示执行此方法必须具有指定的权限 //查询 @RequiresPermissions(value = &quot;user-find&quot;) public String find() { return &quot;查询用户成功&quot;; } ( 2 ) RequiresRoles 配置到方法上，表明执行此方法必须具有指定的角色 //查询 @RequiresRoles(value = &quot;系统管理员&quot;) public String find() { return &quot;查询用户成功&quot;; } 基于注解的配置方式进行授权，一旦操作用户不具备操作权限，目标方法不会被执行，而且会抛出AuthorizationException 异常。所以需要做好统一异常处理完成未授权处理 5.2 Shiro中的会话管理 在Shiro里所有用户的会话信息都会由Shiro来进行控制,Shiro提供的会话可以用于JavaSE/JavaEE环境,不依赖任何底层容器,可以独立使用,是完整的会话模块. 通过Shiro的会话管理器,(SecurityManager) 进行统一的会话管理 5.2.1 什么是Shiro的会话管理 SessionManager(会话管理器) : 管理所有的Subject的session包括创建,维护,删除,失效,验证等工作. SessionManager是顶层组件,由SecurityManager管理. Shiro提供了三个默认实现 : DefaultSessionManager : 用于JavaSE环境 ServletContainerSessionManager : 用于Web环境,直接使用Servlet容器的会话. DefaultWebSessionManager : 用于Web环境,自己维护会话,(自己维护着会话,直接废弃了Servlet容器的会话管理). 在web程序中,通过Shiro的Subject.login()方法登录成功以后,用户的认证信息实际上是保存在HttpSession中的. 通过如下代码验证 : //登录成功后，打印所有session内容 @RequestMapping(value=&quot;/show&quot;) public String show(HttpSession session) { // 获取session中所有的键值 Enumeration&lt;?&gt; enumeration = session.getAttributeNames(); // 遍历enumeration中的 while (enumeration.hasMoreElements()) { // 获取session键值 String name = enumeration.nextElement().toString(); // 根据键值取session中的值 Object value = session.getAttribute(name); // 打印结果 System.out.println(&quot;&lt;B&gt;&quot; + name + &quot;&lt;/B&gt;=&quot; + value + &quot;&lt;br&gt;/n&quot;); } return &quot;查看session成功&quot;; } 5.2.2 应用场景分析 在分布式系统或者微服务架构下，都是通过统一的认证中心进行用户认证。如果使用默认会话管理，用户信息只会保存到一台服务器上。那么其他服务就需要进行会话的同步。 会话管理器可以指定sessionId的生成以及获取方式。 通过sessionDao完成模拟session存入，取出等操作 5.2.3 Shiro结合Redis的统一会话管理 5.2.3.1 步骤分析 5.2.3.2 构建环境 ( 1 ) 使用开源组件Shiro-Redis可以方便的构建Shiro与Redis的整合工程 &lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; ( 2 ) 在Spring Boot配置文件中添加Redis的配置 redis: host: 127.0.0.1 port: 6379 5.2.3.3 自定义Shiro会话管理器 /** * 自定义的sessionManager */ public class CustomSessionManager extends DefaultWebSessionManager { /** * 头信息中具有sessionid * 请求头：Authorization： sessionid * * 指定sessionId的获取方式 */ protected Serializable getSessionId(ServletRequest request, ServletResponse response) { //获取请求头Authorization中的数据 String id = WebUtils.toHttp(request).getHeader(&quot;Authorization&quot;); if(StringUtils.isEmpty(id)) { //如果没有携带，生成新的sessionId return super.getSessionId(request,response); }else{ //返回sessionId； request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, &quot;header&quot;); request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id); request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE); return id; } } } 5.2.3.4 配置Shiro基于Redis的会话管理 在Shiro配置类 cn.xgl6.ShiroConfiguration 配置 配置Shiro的RedisManager , 通过shiro-redis包提供的RedisManager统一对Redis操作 @Value(&quot;${spring.redis.host}&quot;) private String host; @Value(&quot;${spring.redis.port}&quot;) private int port; //配置shiro redisManager public RedisManager redisManager() { RedisManager redisManager = new RedisManager(); redisManager.setHost(host); redisManager.setPort(port); return redisManager; } Shiro内部有自己的本地缓存机制,为了更加统一方便管理,全部替换成Redis实现 //配置Shiro的缓存管理器 //使用redis实现 public RedisCacheManager cacheManager() { RedisCacheManager redisCacheManager = new RedisCacheManager(); redisCacheManager.setRedisManager(redisManager()); return redisCacheManager; } 配置SessionDao,使用shiro-redis包提供的SessionDao /** * RedisSessionDAO shiro sessionDao层的实现 通过redis * 使用的是shiro-redis开源插件 */ public RedisSessionDAO redisSessionDAO() { RedisSessionDAO redisSessionDAO = new RedisSessionDAO(); redisSessionDAO.setRedisManager(redisManager()); return redisSessionDAO; } 配置会话管理器,指定SessionDao的依赖关系 /** * 3.会话管理器 */ public DefaultWebSessionManager sessionManager() { CustomSessionManager sessionManager = new CustomSessionManager(); sessionManager.setSessionDAO(redisSessionDAO()); return sessionManager; } 统一交给SecurityManager管理 //配置安全管理器 @Bean public SecurityManager securityManager(CustomRealm realm) { //使用默认的安全管理器 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(realm); // 自定义session管理 使用redis securityManager.setSessionManager(sessionManager()); // 自定义缓存实现 使用redis securityManager.setCacheManager(cacheManager()); //将自定义的realm交给安全管理器统一调度管理 securityManager.setRealm(realm); return securityManager; } ","link":"https://xgl6.github.io/post/shiro/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静 态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 啦啦啦 😘 Enjoy~ ","link":"https://xgl6.github.io/post/hello-gridea/"}]}